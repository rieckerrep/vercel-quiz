proname,pg_get_functiondef
handle_new_user,"CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
begin
  insert into public.profiles(id)
  values (new.id);
  return new;
end;
$function$
"
update_level_from_stats(),"CREATE OR REPLACE FUNCTION public.""update_level_from_stats()""()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$BEGIN
  -- Suche das höchste Level, dessen xp_required <= NEW.total_xp
  SELECT level_number
    INTO NEW.level
    FROM levels
    WHERE xp_required <= NEW.total_xp
    ORDER BY xp_required DESC
    LIMIT 1;

  RETURN NEW;
END;$function$
"
update_league_groups,"CREATE OR REPLACE FUNCTION public.update_league_groups()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  WITH ranked AS (
    SELECT 
      user_id,
      current_league,  -- z. B. ""Holzliga"", ""Bronzeliga"" etc.
      ROW_NUMBER() OVER (PARTITION BY current_league ORDER BY total_xp DESC) AS rn
    FROM user_stats
  )
  UPDATE user_stats us
  SET league_group = CONCAT(us.current_league, ' ', CEIL(r.rn::numeric / 30))
  FROM ranked r
  WHERE us.user_id = r.user_id;
END;
$function$
"
get_player_leaderboard,"CREATE OR REPLACE FUNCTION public.get_player_leaderboard()
 RETURNS TABLE(username text, xp bigint)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT p.username,
           s.total_xp AS xp
    FROM user_stats s
    JOIN profiles p ON p.id = s.user_id
    ORDER BY s.total_xp DESC
    LIMIT 50
$function$
"
purchase_item,"CREATE OR REPLACE FUNCTION public.purchase_item(user_id uuid, item_id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  item_price INTEGER;
  user_coins INTEGER;
  current_quantity INTEGER;
BEGIN
  -- Preis des Items holen
  SELECT price INTO item_price FROM items WHERE id = item_id;
  IF item_price IS NULL THEN
    RETURN '🚫 Item existiert nicht';
  END IF;

  -- Coins des Nutzers holen
  SELECT coins INTO user_coins FROM profiles WHERE id = user_id;
  IF user_coins IS NULL THEN
    RETURN '🚫 Nutzer nicht gefunden';
  END IF;

  -- Prüfen, ob genug Coins vorhanden sind
  IF user_coins < item_price THEN
    RETURN '🚫 Nicht genug Coins';
  END IF;

  -- Coins abziehen
  UPDATE profiles
  SET coins = coins - item_price
  WHERE id = user_id;

  -- Prüfen, ob Item bereits vorhanden ist
  SELECT quantity INTO current_quantity
  FROM user_items
  WHERE user_id = user_id AND item_id = item_id;

  IF FOUND THEN
    -- Item existiert → Anzahl erhöhen
    UPDATE user_items
    SET quantity = quantity + 1
    WHERE user_id = user_id AND item_id = item_id;
  ELSE
    -- Neues Item eintragen
    INSERT INTO user_items (user_id, item_id, quantity)
    VALUES (user_id, item_id, 1);
  END IF;

  RETURN '✅ Item erfolgreich gekauft';
END;
$function$
"
reset_uni_leaderboard,"CREATE OR REPLACE FUNCTION public.reset_uni_leaderboard()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Beispiel: Setze das monatliche Score-Feld zurück
  UPDATE universities
  SET monthly_uni_scores = 0;
  
  RAISE NOTICE 'University leaderboard has been reset.';
END;
$function$
"
get_user_items,"CREATE OR REPLACE FUNCTION public.get_user_items(p_user_id uuid)
 RETURNS TABLE(item_id uuid, name text, type text, icon_url text, quantity integer)
 LANGUAGE sql
AS $function$
  SELECT
    ui.item_id,
    i.name,
    i.type,
    i.icon_url,
    ui.quantity
  FROM user_items ui
  JOIN items i ON ui.item_id = i.id
  WHERE ui.user_id = p_user_id;
$function$
"
reset_leagues,"CREATE OR REPLACE FUNCTION public.reset_leagues()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
  rec RECORD;
  promotion_threshold CONSTANT INTEGER := 10;  -- Top 10
  demotion_threshold CONSTANT INTEGER := 5;    -- Unterste 5
  next_league TEXT;
  prev_league TEXT;
BEGIN
  -- Für jede existierende Liga in user_stats
  FOR rec IN
    SELECT DISTINCT current_league FROM user_stats
  LOOP
    -- Bestimme anhand des aktuellen Liga-Namens, welches die nächsthöhere und nächstniedrigere Liga ist.
    IF rec.current_league = 'Holzliga' THEN
      next_league := 'Bronzeliga';
      prev_league := NULL;  -- Keine Abstufung, da Holzliga die unterste ist.
    ELSIF rec.current_league = 'Bronzeliga' THEN
      next_league := 'Silberliga';
      prev_league := 'Holzliga';
    ELSIF rec.current_league = 'Silberliga' THEN
      next_league := 'Goldliga';
      prev_league := 'Bronzeliga';
    ELSIF rec.current_league = 'Goldliga' THEN
      next_league := 'Platinliga';
      prev_league := 'Silberliga';
    ELSIF rec.current_league = 'Platinliga' THEN
      next_league := 'Champions League';
      prev_league := 'Goldliga';
    ELSE
      next_league := NULL;
      prev_league := NULL;
    END IF;

    -- Befördere die Top 10 (Promotion), sofern es eine nächste Liga gibt:
    IF next_league IS NOT NULL THEN
      WITH ranked AS (
        SELECT user_id, total_xp,
               ROW_NUMBER() OVER (ORDER BY total_xp DESC) as rn
        FROM user_stats
        WHERE current_league = rec.current_league
      )
      UPDATE user_stats
      SET current_league = next_league
      FROM ranked
      WHERE user_stats.user_id = ranked.user_id
        AND ranked.rn <= promotion_threshold;
    END IF;

    -- Stufe die untersten 5 Spieler ab (Demotion), sofern es eine niedrigere Liga gibt:
    IF prev_league IS NOT NULL THEN
      WITH ranked AS (
        SELECT user_id, total_xp,
               ROW_NUMBER() OVER (ORDER BY total_xp ASC) as rn
        FROM user_stats
        WHERE current_league = rec.current_league
      )
      UPDATE user_stats
      SET current_league = prev_league
      FROM ranked
      WHERE user_stats.user_id = ranked.user_id
        AND ranked.rn <= demotion_threshold;
    END IF;
  END LOOP;

  RAISE NOTICE 'Leagues have been reset with promotion/demotion logic applied.';
END;
$function$
"
get_university_leaderboard,"CREATE OR REPLACE FUNCTION public.get_university_leaderboard()
 RETURNS TABLE(university text, xp_sum bigint)
 LANGUAGE sql
AS $function$
    SELECT 
        p.university,
        COALESCE(SUM(us.total_xp), 0) as xp_sum
    FROM profiles p
    LEFT JOIN user_stats us ON p.id = us.user_id
    WHERE p.university IS NOT NULL
    GROUP BY p.university
    ORDER BY xp_sum DESC;
$function$
"
start_pvp_match,"CREATE OR REPLACE FUNCTION public.start_pvp_match(user_id uuid, opponent_id uuid)
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$
DECLARE
  new_match_id UUID;
BEGIN
  -- Match anlegen
  INSERT INTO pvp_matches (status)
  VALUES ('pending')
  RETURNING id INTO new_match_id;

  -- Beide Teilnehmer eintragen
  INSERT INTO match_participants (match_id, user_id)
  VALUES (new_match_id, user_id),
         (new_match_id, opponent_id);

  -- Match-ID zurückgeben
  RETURN new_match_id;
END;
$function$
"
get_league_leaderboard,"CREATE OR REPLACE FUNCTION public.get_league_leaderboard(league_name text)
 RETURNS TABLE(username text, xp bigint)
 LANGUAGE sql
 SECURITY DEFINER
AS $function$
    SELECT p.username,
           s.total_xp AS xp
    FROM user_stats s
    JOIN profiles p ON p.id = s.user_id
    WHERE s.current_league = league_name
    ORDER BY s.total_xp DESC
$function$
"
update_match_score,"CREATE OR REPLACE FUNCTION public.update_match_score(match_id uuid, user_id uuid, is_correct boolean)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN
  -- Punktestand für den Spieler aktualisieren
  UPDATE match_participants
  SET score = score + CASE WHEN is_correct THEN 10 ELSE 0 END
  WHERE match_id = match_id AND user_id = user_id;
END;
$function$
"
submit_pvp_answer,"CREATE OR REPLACE FUNCTION public.submit_pvp_answer(user_id uuid, match_id uuid, question_id uuid, is_correct boolean)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  already_answered INTEGER;
BEGIN
  -- Prüfen, ob Frage schon beantwortet wurde (Anti-Farming)
  SELECT COUNT(*) INTO already_answered
  FROM pvp_answers
  WHERE user_id = user_id
    AND match_id = match_id
    AND question_id = question_id;

  IF already_answered > 0 THEN
    RETURN '🚫 Frage bereits beantwortet';
  END IF;

  -- Antwort eintragen
  INSERT INTO pvp_answers (user_id, match_id, question_id, is_correct)
  VALUES (user_id, match_id, question_id, is_correct);

  -- Punkte vergeben bei richtiger Antwort
  IF is_correct THEN
    UPDATE match_participants
    SET score = score + 10
    WHERE user_id = user_id AND match_id = match_id;
  END IF;

  RETURN '✅ Antwort gespeichert';
END;
$function$
"
update_streak,"CREATE OR REPLACE FUNCTION public.update_streak(user_id uuid, is_correct boolean)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  streak_value INTEGER;
BEGIN
  -- Sicherstellen, dass Streak-Eintrag existiert
  INSERT INTO user_streaks (user_id, current_streak)
  VALUES (user_id, 0)
  ON CONFLICT (user_id) DO NOTHING;

  IF is_correct THEN
    -- Streak erhöhen
    UPDATE user_streaks
    SET current_streak = current_streak + 1,
        last_updated = NOW()
    WHERE user_id = user_id;

    -- Prüfen, ob Streak 3 erreicht wurde
    SELECT current_streak INTO streak_value
    FROM user_streaks
    WHERE user_id = user_id;

    IF streak_value >= 3 THEN
      -- Bonus-XP vergeben
      UPDATE user_stats
      SET xp = xp + 30
      WHERE user_id = user_id;

      -- Streak zurücksetzen
      UPDATE user_streaks
      SET current_streak = 0
      WHERE user_id = user_id;

      RETURN '✅ Streak-Bonus vergeben';
    ELSE
      RETURN '✅ Streak erhöht auf ' || streak_value;
    END IF;

  ELSE
    -- Streak zurücksetzen bei falscher Antwort
    UPDATE user_streaks
    SET current_streak = 0,
        last_updated = NOW()
    WHERE user_id = user_id;

    RETURN '🚫 Streak zurückgesetzt';
  END IF;
END;
$function$
"
update_daily_streak,"CREATE OR REPLACE FUNCTION public.update_daily_streak(user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  berlin_today DATE := timezone('Europe/Berlin', now())::DATE;
  yesterday DATE := berlin_today - INTERVAL '1 day';
  last_date DATE;
BEGIN
  -- Sicherstellen, dass Eintrag existiert
  INSERT INTO daily_streaks (user_id, current_streak, last_active_date)
  VALUES (user_id, 1, berlin_today)
  ON CONFLICT (user_id) DO NOTHING;

  -- Letztes Aktivitätsdatum holen
  SELECT last_active_date INTO last_date
  FROM daily_streaks
  WHERE user_id = user_id;

  IF last_date = berlin_today THEN
    RETURN '✅ Heute bereits gezählt';
  ELSIF last_date = yesterday THEN
    -- Streak +1
    UPDATE daily_streaks
    SET current_streak = current_streak + 1,
        last_active_date = berlin_today,
        last_updated = NOW()
    WHERE user_id = user_id;

    RETURN '🔥 Streak erhöht';
  ELSE
    -- Streak reset
    UPDATE daily_streaks
    SET current_streak = 1,
        last_active_date = berlin_today,
        last_updated = NOW()
    WHERE user_id = user_id;

    RETURN '❄️ Streak zurückgesetzt';
  END IF;
END;
$function$
"
get_user_progress,"CREATE OR REPLACE FUNCTION public.get_user_progress(user_id uuid, chapter_id bigint)
 RETURNS TABLE(question_id bigint, is_answered boolean, is_correct boolean)
 LANGUAGE sql
AS $function$
  SELECT
    q.id AS question_id,
    aq.question_id IS NOT NULL AS is_answered,
    COALESCE(aq.is_correct, false) AS is_correct
  FROM questions q
  LEFT JOIN answered_questions aq
    ON q.id = aq.question_id AND aq.user_id = get_user_progress.user_id
  WHERE q.chapter_id = get_user_progress.chapter_id;
$function$
"
is_quiz_completed,"CREATE OR REPLACE FUNCTION public.is_quiz_completed(user_id uuid, chapter_id bigint)
 RETURNS boolean
 LANGUAGE sql
AS $function$
  SELECT COUNT(DISTINCT aq.question_id) = COUNT(q.id)
  FROM questions q
  LEFT JOIN answered_questions aq
    ON q.id = aq.question_id AND aq.user_id = is_quiz_completed.user_id
  WHERE q.chapter_id = is_quiz_completed.chapter_id;
$function$
"
has_answered,"CREATE OR REPLACE FUNCTION public.has_answered(user_id uuid, question_id bigint)
 RETURNS boolean
 LANGUAGE sql
AS $function$
  SELECT EXISTS (
    SELECT 1
    FROM answered_questions
    WHERE user_id = has_answered.user_id
      AND question_id = has_answered.question_id
  );
$function$
"
use_item,"CREATE OR REPLACE FUNCTION public.use_item(user_id uuid, item_id uuid, question_id bigint)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  remaining INTEGER;
BEGIN
  -- Check: hat der User das Item überhaupt?
  SELECT quantity INTO remaining
  FROM user_items
  WHERE user_id = user_id AND item_id = item_id;

  IF remaining IS NULL OR remaining <= 0 THEN
    RETURN '🚫 Kein Item vorhanden';
  END IF;

  -- Item verbrauchen
  UPDATE user_items
  SET quantity = quantity - 1
  WHERE user_id = user_id AND item_id = item_id;

  RETURN '✅ Item verwendet';
END;
$function$
"
get_streaks,"CREATE OR REPLACE FUNCTION public.get_streaks(user_id uuid)
 RETURNS TABLE(quiz_streak integer, daily_streak integer, last_quiz_update timestamp without time zone, last_daily_active date)
 LANGUAGE sql
AS $function$
  SELECT
    COALESCE(us.current_streak, 0) AS quiz_streak,
    COALESCE(ds.current_streak, 0) AS daily_streak,
    us.last_updated,
    ds.last_active_date
  FROM profiles p
  LEFT JOIN user_streaks us ON us.user_id = p.id
  LEFT JOIN daily_streaks ds ON ds.user_id = p.id
  WHERE p.id = get_streaks.user_id;
$function$
"
submit_pvp_response,"CREATE OR REPLACE FUNCTION public.submit_pvp_response(user_id uuid, match_id uuid, question_id bigint, is_correct boolean, response_time_ms integer)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  damage_to_enemy INTEGER := 0;
  self_penalty INTEGER := 0;
  opponent_id UUID;
BEGIN
  -- Anti-Farming: Frage schon beantwortet?
  IF EXISTS (
    SELECT 1 FROM pvp_responses
    WHERE match_id = match_id AND user_id = user_id AND question_id = question_id
  ) THEN
    RETURN '🚫 Frage bereits beantwortet';
  END IF;

  -- Gegner ermitteln
  SELECT user_id INTO opponent_id
  FROM pvp_participants
  WHERE match_id = match_id AND user_id != user_id;

  -- Schadensberechnung
  IF is_correct THEN
    -- Weniger Zeit = mehr Schaden (Basis: 20 - response_time_ms / 1000 capped)
    damage_to_enemy := GREATEST(10, LEAST(20, 25 - response_time_ms / 1000));
  ELSE
    self_penalty := 10;
  END IF;

  -- Antwort speichern
  INSERT INTO pvp_responses (match_id, user_id, question_id, is_correct, damage_done, self_damage)
  VALUES (match_id, user_id, question_id, is_correct, damage_to_enemy, self_penalty);

  -- HP aktualisieren
  IF is_correct THEN
    UPDATE pvp_participants
    SET hp = hp - damage_to_enemy
    WHERE match_id = match_id AND user_id = opponent_id;
  ELSE
    UPDATE pvp_participants
    SET hp = hp - self_penalty
    WHERE match_id = match_id AND user_id = user_id;
  END IF;

  RETURN '✅ Antwort verarbeitet';
END;
$function$
"
finalize_pvp_match,"CREATE OR REPLACE FUNCTION public.finalize_pvp_match(match_id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  p1 UUID;
  p2 UUID;
  p1_hp INTEGER;
  p2_hp INTEGER;
  winner UUID;
  loser UUID;
BEGIN
  -- Teilnehmer ermitteln
  SELECT user_id INTO p1 FROM pvp_participants WHERE match_id = match_id LIMIT 1;
  SELECT user_id INTO p2 FROM pvp_participants WHERE match_id = match_id AND user_id != p1;

  -- HP beider Spieler
  SELECT hp INTO p1_hp FROM pvp_participants WHERE match_id = match_id AND user_id = p1;
  SELECT hp INTO p2_hp FROM pvp_participants WHERE match_id = match_id AND user_id = p2;

  -- Prüfen, ob Match schon beendet
  IF EXISTS (
    SELECT 1 FROM pvp_matches WHERE id = match_id AND status = 'finished'
  ) THEN
    RETURN '🚫 Match wurde bereits abgeschlossen';
  END IF;

  -- Sieger bestimmen
  IF p1_hp > p2_hp THEN
    winner := p1;
    loser := p2;
  ELSIF p2_hp > p1_hp THEN
    winner := p2;
    loser := p1;
  ELSE
    winner := NULL; -- Unentschieden
  END IF;

  -- Matchstatus aktualisieren
  UPDATE pvp_matches SET status = 'finished' WHERE id = match_id;

  -- XP/Coins vergeben
  IF winner IS NOT NULL THEN
    -- Gewinner
    UPDATE user_stats SET xp = xp + 50, coins = coins + 50 WHERE user_id = winner;
    -- Verlierer
    UPDATE user_stats SET xp = xp + 20, coins = coins + 20 WHERE user_id = loser;
  ELSE
    -- Unentschieden
    UPDATE user_stats SET xp = xp + 30, coins = coins + 30
    WHERE user_id IN (p1, p2);
  END IF;

  RETURN '✅ Match abgeschlossen';
END;
$function$
"
update_level_on_xp_change,"CREATE OR REPLACE FUNCTION public.update_level_on_xp_change(user_id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$DECLARE
  user_xp INTEGER;
  best_level_id INTEGER;
  current_level_id INTEGER;
BEGIN
  -- Aktuelle XP holen
  SELECT xp INTO user_xp
  FROM user_stats
  WHERE user_id = user_id;

  -- Bestmögliches Level ermitteln (alle Levels, die die XP-Schwelle erfüllen)
  SELECT id INTO best_level_id
  FROM levels
  WHERE xp_required <= user_xp
  ORDER BY xp_required DESC
  LIMIT 1;

  -- Aktuelles Level holen
  SELECT level_id INTO current_level_id
  FROM user_stats
  WHERE user_id = user_id;

  -- Nur aktualisieren, wenn höher
  IF best_level_id IS NOT NULL AND best_level_id > current_level_id THEN
    UPDATE user_stats
    SET level_id = best_level_id
    WHERE user_id = user_id;

    RETURN '🏆 Level up auf ' || best_level_id;
  END IF;

  RETURN 'ℹ️ Level bleibt gleich';
END;$function$
"
get_subject_breakdown_for_user,"CREATE OR REPLACE FUNCTION public.get_subject_breakdown_for_user(_user_id uuid)
 RETURNS TABLE(subject_name text, correct_count integer, wrong_count integer, total integer, correct_percent integer)
 LANGUAGE sql
 STABLE
AS $function$
  SELECT
    s.name AS subject_name,
    SUM(CASE WHEN aq.is_correct THEN 1 ELSE 0 END) AS correct_count,
    SUM(CASE WHEN aq.is_correct THEN 0 ELSE 1 END) AS wrong_count,
    COUNT(*) AS total,
    ROUND( (SUM(CASE WHEN aq.is_correct THEN 1 ELSE 0 END)::decimal / COUNT(*) * 100) )::int AS correct_percent
  FROM answered_questions aq
  JOIN questions q
    ON q.id = aq.question_id
  JOIN chapters ch
    ON ch.id = q.chapter_id
  JOIN courses co
    ON co.id = ch.course_id
  JOIN subjects s
    ON s.id = co.subject_id
  WHERE aq.user_id = _user_id
  GROUP BY s.name
  ORDER BY s.name;
$function$
"
get_university_contributors,"CREATE OR REPLACE FUNCTION public.get_university_contributors(uni_name text)
 RETURNS TABLE(username text, total_xp bigint, user_id text)
 LANGUAGE sql
AS $function$
    SELECT 
        COALESCE(p.username, us.username) as username,
        COALESCE(us.total_xp, 0) as total_xp,
        p.id as user_id
    FROM profiles p
    LEFT JOIN user_stats us ON p.id = us.user_id
    WHERE p.university = uni_name
    ORDER BY us.total_xp DESC NULLS LAST;
$function$
"
update_subquestions_count,"CREATE OR REPLACE FUNCTION public.update_subquestions_count()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  UPDATE questions
  SET subquestions_count = (
    SELECT COUNT(*) FROM cases_subquestions WHERE question_id = NEW.question_id
  )
  WHERE id = NEW.question_id;
  RETURN NEW;
END;
$function$
"
get_user_stats,"CREATE OR REPLACE FUNCTION public.get_user_stats(user_id uuid)
 RETURNS TABLE(xp integer, coins integer, level integer, level_title text, bronze_count integer, silver_count integer, gold_count integer, quiz_streak integer, daily_streak integer)
 LANGUAGE sql
AS $function$
  SELECT
    us.total_xp AS xp,
    us.total_coins AS coins,
    us.level,
    l.level_title,
    COUNT(CASE WHEN um.medal = 'bronze' THEN 1 END) AS bronze_count,
    COUNT(CASE WHEN um.medal = 'silver' THEN 1 END) AS silver_count,
    COUNT(CASE WHEN um.medal = 'gold' THEN 1 END) AS gold_count,
    COALESCE(ust.current_streak, 0) AS quiz_streak,
    COALESCE(dst.current_streak, 0) AS daily_streak
  FROM user_stats us
  LEFT JOIN levels l ON us.level = l.id
  LEFT JOIN user_medals um ON um.user_id = us.user_id
  LEFT JOIN user_streaks ust ON ust.user_id = us.user_id
  LEFT JOIN daily_streaks dst ON dst.user_id = us.user_id
  WHERE us.user_id = get_user_stats.user_id
  GROUP BY us.total_xp, us.total_coins, us.level, l.level_title, ust.current_streak, dst.current_streak;
$function$
"
get_answer_stats,"CREATE OR REPLACE FUNCTION public.get_answer_stats(user_id uuid)
 RETURNS TABLE(subject_name text, correct_answers integer)
 LANGUAGE sql
AS $function$
  SELECT
    s.name AS subject_name,
    COUNT(*) AS correct_answers
  FROM answered_questions aq
  JOIN questions q ON aq.question_id = q.id
  JOIN courses c ON q.course_id = c.id
  JOIN subjects s ON c.subject_id = s.id
  WHERE aq.user_id = get_answer_stats.user_id
    AND aq.is_correct = TRUE
  GROUP BY s.name
  ORDER BY correct_answers DESC;
$function$
"
calculate_and_award_xp,"CREATE OR REPLACE FUNCTION public.calculate_and_award_xp(p_user_id uuid, p_correct_question_ids bigint[], p_correct_subquestion_ids bigint[])
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_new_question_ids BIGINT[];
  v_new_subquestion_ids BIGINT[];
  v_total_xp INTEGER := 0;
  v_total_coins INTEGER := 0;
  v_total_correct INTEGER := 0;
BEGIN
  -- Normale Fragen: nur solche mit XP/Coins laut Typentabelle
  SELECT ARRAY_AGG(q.id)
  INTO v_new_question_ids
  FROM questions q
  JOIN question_types qt ON q.question_type_id = qt.id
  WHERE q.id = ANY(p_correct_question_ids)
    AND (qt.base_xp > 0 OR qt.base_coins > 0)
    AND NOT EXISTS (
      SELECT 1 FROM answered_questions aq
      WHERE aq.user_id = p_user_id AND aq.question_id = q.id
    );

  -- XP/Coins aus normalen Fragen berechnen
  IF v_new_question_ids IS NOT NULL THEN
    SELECT
      COALESCE(SUM(qt.base_xp), 0),
      COALESCE(SUM(qt.base_coins), 0),
      COUNT(*)
    INTO v_total_xp, v_total_coins, v_total_correct
    FROM questions q
    JOIN question_types qt ON q.question_type_id = qt.id
    WHERE q.id = ANY(v_new_question_ids);
  END IF;

  -- Subfragen: feste 5 XP pro korrekt beantworteter Subfrage
  SELECT ARRAY_AGG(cs.id)
  INTO v_new_subquestion_ids
  FROM cases_subquestions cs
  WHERE cs.id = ANY(p_correct_subquestion_ids)
    AND NOT EXISTS (
      SELECT 1 FROM answered_questions aq
      WHERE aq.user_id = p_user_id AND aq.question_id = cs.id
    );

  IF v_new_subquestion_ids IS NOT NULL THEN
    v_total_xp := v_total_xp + array_length(v_new_subquestion_ids, 1) * 5;
    v_total_correct := v_total_correct + array_length(v_new_subquestion_ids, 1);
    -- Coins für Subfragen? → aktuell: 0
  END IF;

  -- Eintragen beantworteter Fragen
  IF v_new_question_ids IS NOT NULL THEN
    INSERT INTO answered_questions (user_id, question_id, is_correct, answered_at)
    SELECT p_user_id, unnest(v_new_question_ids), TRUE, NOW();
  END IF;

  IF v_new_subquestion_ids IS NOT NULL THEN
    INSERT INTO answered_questions (user_id, question_id, is_correct, answered_at)
    SELECT p_user_id, unnest(v_new_subquestion_ids), TRUE, NOW();
  END IF;

  -- Stats aktualisieren
  UPDATE user_stats
  SET total_xp = total_xp + v_total_xp,
      total_coins = total_coins + v_total_coins,
      correct_answers = correct_answers + v_total_correct,
      questions_answered = questions_answered + v_total_correct
  WHERE user_id = p_user_id;

  -- Folgeaktionen
  PERFORM update_level_on_xp_change(p_user_id);
  PERFORM update_streak(p_user_id, TRUE);
  PERFORM update_daily_streak(p_user_id);

  RETURN '✅ ' || v_total_xp || ' XP und ' || v_total_coins || ' Coins für ' || v_total_correct || ' Antworten vergeben.';
END;
$function$
"
apply_penalty_for_wrong_answers,"CREATE OR REPLACE FUNCTION public.apply_penalty_for_wrong_answers(p_user_id uuid, p_wrong_question_ids bigint[])
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_new_wrong_ids BIGINT[];
  v_total_coin_loss INTEGER := 0;
BEGIN
  -- Neue, falsche Antworten identifizieren (Anti-Farming)
  SELECT ARRAY_AGG(q.id)
  INTO v_new_wrong_ids
  FROM questions q
  WHERE q.id = ANY(p_wrong_question_ids)
    AND NOT EXISTS (
      SELECT 1 FROM answered_questions aq
      WHERE aq.user_id = p_user_id AND aq.question_id = q.id
    );

  -- Gesamtverlust berechnen
  IF v_new_wrong_ids IS NOT NULL THEN
    SELECT COALESCE(SUM(qt.base_lose_coins), 0)
    INTO v_total_coin_loss
    FROM questions q
    JOIN question_types qt ON q.question_type_id = qt.id
    WHERE q.id = ANY(v_new_wrong_ids)
      AND qt.base_lose_coins > 0;

    -- Als falsch gespeichert
    INSERT INTO answered_questions (user_id, question_id, is_correct, answered_at)
    SELECT p_user_id, unnest(v_new_wrong_ids), FALSE, NOW();

    -- Coins abziehen
    UPDATE user_stats
    SET total_coins = GREATEST(total_coins - v_total_coin_loss, 0)
    WHERE user_id = p_user_id;
  END IF;

  RETURN '🚫 ' || COALESCE(v_total_coin_loss, 0) || ' Coins abgezogen für falsche Antworten.';
END;
$function$
"
assign_medals_on_completion,"CREATE OR REPLACE FUNCTION public.assign_medals_on_completion(p_user_id uuid, p_chapter_id uuid)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_total_questions INTEGER;
  v_correct_answers INTEGER;
  v_percentage NUMERIC;
  v_medal TEXT;
BEGIN
  -- Gesamtzahl der Fragen in Kapitel
  SELECT COUNT(*) INTO v_total_questions
  FROM questions
  WHERE chapter_id = p_chapter_id;

  -- Anzahl richtiger Antworten des Nutzers in diesem Kapitel
  SELECT COUNT(*) INTO v_correct_answers
  FROM answered_questions aq
  JOIN questions q ON aq.question_id = q.id
  WHERE q.chapter_id = p_chapter_id
    AND aq.user_id = p_user_id
    AND aq.is_correct = TRUE;

  IF v_total_questions = 0 THEN
    RETURN '🚫 Keine Fragen in diesem Kapitel.';
  END IF;

  v_percentage := (v_correct_answers * 100.0) / v_total_questions;

  -- Medaille bestimmen
  IF v_percentage >= 100 THEN
    v_medal := 'gold';
  ELSIF v_percentage >= 75 THEN
    v_medal := 'silver';
  ELSIF v_percentage >= 50 THEN
    v_medal := 'bronze';
  ELSE
    RETURN '❌ Keine Medaille vergeben.';
  END IF;

  -- Nur eintragen, wenn noch nicht vorhanden oder niedrigerwertig
  INSERT INTO user_medals (user_id, chapter_id, medal)
  VALUES (p_user_id, p_chapter_id, v_medal)
  ON CONFLICT (user_id, chapter_id) DO UPDATE
  SET medal = CASE
    WHEN EXCLUDED.medal = 'gold' THEN 'gold'
    WHEN EXCLUDED.medal = 'silver' AND user_medals.medal = 'bronze' THEN 'silver'
    WHEN EXCLUDED.medal = 'bronze' AND user_medals.medal IS NULL THEN 'bronze'
    ELSE user_medals.medal
  END;

  RETURN '✅ Medaille vergeben: ' || v_medal;
END;
$function$
"
get_quiz_summary,"CREATE OR REPLACE FUNCTION public.get_quiz_summary(p_user_id uuid, p_chapter_id uuid)
 RETURNS TABLE(xp_gained integer, xp_possible integer)
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_main_xp_gained INTEGER := 0;
  v_sub_xp_gained INTEGER := 0;

  v_main_xp_possible INTEGER := 0;
  v_sub_xp_possible INTEGER := 0;
BEGIN
  -- XP durch korrekt beantwortete Hauptfragen (inkl. DragDrop, aber nur wenn ganz richtig)
  SELECT COALESCE(SUM(qt.base_xp), 0)
  INTO v_main_xp_gained
  FROM answered_questions aq
  JOIN questions q ON aq.question_id = q.id
  JOIN question_types qt ON q.question_type_id = qt.id_uuid
  WHERE q.chapter_id = p_chapter_id
    AND aq.user_id = p_user_id
    AND aq.is_correct = TRUE;

  -- XP durch korrekt beantwortete Subfragen (z. B. Fallfragen)
  SELECT COUNT(*) * 5
  INTO v_sub_xp_gained
  FROM answered_questions aq
  JOIN cases_subquestions cs ON aq.question_id = cs.id
  JOIN questions q ON cs.question_id = q.id
  WHERE q.chapter_id = p_chapter_id
    AND aq.user_id = p_user_id
    AND aq.is_correct = TRUE;

  -- Mögliche XP aus Hauptfragen (inkl. DragDrop als ganze Einheit)
  SELECT COALESCE(SUM(qt.base_xp), 0)
  INTO v_main_xp_possible
  FROM questions q
  JOIN question_types qt ON q.question_type_id = qt.id_uuid
  WHERE q.chapter_id = p_chapter_id;

  -- Mögliche XP aus Subfragen
  SELECT COUNT(*) * 5
  INTO v_sub_xp_possible
  FROM cases_subquestions cs
  JOIN questions q ON cs.question_id = q.id
  WHERE q.chapter_id = p_chapter_id;

  RETURN QUERY SELECT
    v_main_xp_gained + v_sub_xp_gained AS xp_gained,
    v_main_xp_possible + v_sub_xp_possible AS xp_possible;
END;
$function$
"
submit_answer,"CREATE OR REPLACE FUNCTION public.submit_answer(p_user_id uuid, p_question_id uuid, p_is_correct boolean)
 RETURNS jsonb
 LANGUAGE plpgsql
AS $function$
DECLARE
  v_xp_awarded INTEGER := 0;
  v_coins_awarded INTEGER := 0;
  v_chapter_id UUID;
  v_current_progress INTEGER;
  v_new_progress INTEGER;
  already_answered BOOLEAN;
BEGIN
  -- Anti-Farming: Prüfen, ob die Frage schon beantwortet wurde
  SELECT TRUE INTO already_answered
  FROM answered_questions
  WHERE user_id = p_user_id AND question_id = p_question_id;

  IF already_answered THEN
    RETURN json_build_object('error', '🚫 Diese Frage wurde bereits beantwortet.');
  END IF;

  -- Kapitel aus der Frage ermitteln
  SELECT chapter_id INTO v_chapter_id
  FROM questions
  WHERE id = p_question_id;

  -- Antwort speichern
  INSERT INTO answered_questions (user_id, question_id, is_correct, chapter_id, answered_at)
  VALUES (p_user_id, p_question_id, p_is_correct, v_chapter_id, NOW());

  -- Berechne XP und Coins
  v_xp_awarded := calculate_and_award_xp(p_user_id, CASE WHEN p_is_correct THEN 1 ELSE 0 END, ARRAY[p_question_id]);

  -- Coins: 10 für richtige Antwort, 0 für falsche Antwort
  v_coins_awarded := CASE WHEN p_is_correct THEN 10 ELSE 0 END;

  -- Update der user_stats: XP, Coins und korrekt beantwortete Fragen
  UPDATE user_stats
  SET
    total_coins = COALESCE(total_coins, 0) + v_coins_awarded,
    questions_answered = COALESCE(questions_answered, 0) + 1,
    correct_answers = COALESCE(correct_answers, 0) + CASE WHEN p_is_correct THEN 1 ELSE 0 END,
    last_played = NOW()
  WHERE user_id = p_user_id;

  -- Fortschritt berechnen und aktualisieren
  SELECT COALESCE(progress, 0) INTO v_current_progress
  FROM quiz_progress
  WHERE user_id = p_user_id AND chapter_id = v_chapter_id;

  SELECT 
    ROUND((COUNT(*)::float / (SELECT COUNT(*) FROM questions WHERE chapter_id = v_chapter_id)) * 100)::integer
  INTO v_new_progress
  FROM answered_questions
  WHERE user_id = p_user_id AND chapter_id = v_chapter_id AND is_correct = TRUE;

  -- Fortschritt in quiz_progress eintragen oder aktualisieren
  INSERT INTO quiz_progress (user_id, chapter_id, progress, updated_at)
  VALUES (p_user_id, v_chapter_id, v_new_progress, NOW())
  ON CONFLICT (user_id, chapter_id)
  DO UPDATE SET progress = v_new_progress, updated_at = NOW();

  -- Streak und Level-Up prüfen
  PERFORM update_streak(p_user_id, p_is_correct);
  PERFORM update_daily_streak(p_user_id);
  PERFORM update_level_on_xp_change(p_user_id);

  -- Medaillen zuweisen, wenn das Quiz abgeschlossen ist
  IF is_quiz_completed(p_user_id, v_chapter_id) THEN
    PERFORM assign_medals_on_completion(p_user_id, v_chapter_id);
  END IF;

  RETURN json_build_object(
    'xp_awarded', v_xp_awarded,
    'coins_awarded', v_coins_awarded,
    'new_progress', v_new_progress
  );
EXCEPTION
  WHEN OTHERS THEN
    RETURN json_build_object('error', SQLERRM);
END;
$function$
"
create_dragdrop_group,"CREATE OR REPLACE FUNCTION public.create_dragdrop_group()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  INSERT INTO dragdrop_groups (question_id) VALUES (NEW.id);
  RETURN NEW;
END;
$function$
"