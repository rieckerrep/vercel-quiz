---
description: 
globs: 
alwaysApply: false
---
---
description: 
globs: 
alwaysApply: true
---
-- .mdc: Ziel = Supabase RPC-Funktion vollst√§ndig und produktionsbereit erstellen
-- Vorgaben f√ºr Cursor:
-- 1. Die folgende PL/pgSQL-Funktion soll vollst√§ndig implementiert werden ‚Äì **keine Platzhalter**, kein "Rest der Funktion"!
Checke unbedingt die korrekte Tabellen- und Spaltenbezeichnung in [schema_.sql](mdc:supabase/sql-base/schema_.sql)
-- 2. Der Code soll produktionsbereit sein und direkt via `supabase db push` in Supabase funktionieren.
-- 3. Verwende `DROP FUNCTION IF EXISTS ...` mit exakter Signatur vor der Funktion, um doppelte Eintr√§ge zu vermeiden.
-- 4. Ersetze oder erweitere die Funktion **immer vollst√§ndig** ‚Äì keine "todo" oder ausgelassenen Bl√∂cke.
-- 5. R√ºckgabewert ist ein vollst√§ndiges `jsonb_build_object(...)` mit allen relevanten Keys (z.‚ÄØB. xp_awarded, coins_awarded, new_progress, streak, etc.).
-- 6. Verwende ausschlie√ülich reale Tabellen und Spalten aus dem aktuellen Supabase-Schema (kein Beispielcode).
-- 7. Die Funktion muss ausf√ºhrbar, testbar und logisch abgeschlossen sein ‚Äì keine L√ºcken.
-- 8. Ziel: Diese Datei soll beim Speichern direkt einsatzbereit sein, ohne dass manuell erg√§nzt werden muss.
-- 9. Der Workflow ist folgender: Der Ordner "Functions" soll dem entsprechen, was auch in der Datenbank ist
-- 10. Die √úbertragung geht im Ordner Migrations.
11. Wenn ich dich frage, ob wir eine Tabelle oder Spalte brauchen, weil sie nicht vorhanden ist, frage ich dich immer ob sie notwendig ist und in das Quizsystem passt.

Der Workflow f√ºr Standartisierungen im Kurzen ist also folgender (je nachdem was gerade gefragt ist):
I. √úberpr√ºfe immer wie die Tabellen- und Spaltenstruktur aussieht. Die Funktion muss immer der aktuellen Struktur entsprechen. Wenn sie dem nicht entspricht, dann musst du explizit sagen, dass du eine neue Tabelle hinzuf√ºgen oder √§ndern willst. √úberpr√ºfe jedoch vorher, ob die Funktion, die du suchst nicht bereits durch eine andere Tabelle abgedeckt ist. Das ergibt sich aus [schema_.sql](mdc:supabase/sql-base/schema_.sql)
II. Funktion standartisieren 
III. Migration erstellen - bedenke dabei das es die alte Funktion immer mit DROP FUNCTION IF EXISTS entfernt werden soll. Es darf keine doppelten Funktionen geben.
IV. DB Subapase Push, wenn ich das sage - wenn wir mehrere Funktionen im Fl√∂w √§ndern, dann pushen wir alle gemeinsam.

Checke:
‚úÖ Schema-Referenz (public.) bei DROP FUNCTION
‚úÖ Schema-Referenz (public.) bei CREATE FUNCTION
‚úÖ Vollst√§ndige Parameter-Liste
‚úÖ Korrekte Tabellenstruktur

Der Workflow f√ºr Anpassungen oder √Ñnderungen im Kurzen ist also folgender (je nachdem was gerade gefragt ist):
I. √úberpr√ºfe immer wie die Tabellen- und Spaltenstruktur aussieht. Die Funktion muss immer der aktuellen Struktur entsprechen. Wenn sie dem nicht entspricht, dann musst du explizit sagen, dass du eine neue Tabelle hinzuf√ºgen oder √§ndern willst. √úberpr√ºfe jedoch vorher, ob die Funktion, die du suchst nicht bereits durch eine andere Tabelle abgedeckt ist. Die Tabellenstruktur ergibt sich aus [schema_.sql](mdc:supabase/sql-base/schema_.sql)
II. Funktion √§ndern
III. Entsprechende Stellen im Frontend-Code anpassen, FALLS DAS NOTWENDIG IST! 
IV. Migration erstellen.
V. DB Subapase Push, wenn ich das sage.

-- üí° Hinweis: Nach Speichern wird diese Datei mit `supabase db push` deployed ‚Äì stelle sicher, dass keine SQL-Fehler vorhanden sind.

-- ‚ú≥Ô∏è Beispielname: submit_answer.sql
-- ‚ú≥Ô∏è Speicherort: /supabase/functions/
